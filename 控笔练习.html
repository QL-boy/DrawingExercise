<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>专业数位板控笔训练系统 (高级版 v3)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles */
        body {
            font-family: 'Inter', 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            overscroll-behavior: none; /* Prevent pull-to-refresh */
        }
        /* Style for range input thumb */
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none; width: 20px; height: 20px;
            background: #3b82f6; /* blue-500 */ border-radius: 50%; cursor: pointer;
        }
        input[type="range"]::-moz-range-thumb {
            width: 20px; height: 20px; background: #3b82f6; /* blue-500 */
            border-radius: 50%; cursor: pointer; border: none;
        }
        /* Style for progress bar */
        progress {
            appearance: none; -webkit-appearance: none; border: none;
            border-radius: 9999px; height: 10px;
        }
        progress::-webkit-progress-bar { background-color: #e5e7eb; border-radius: 9999px; } /* gray-200 */
        progress::-webkit-progress-value { background-color: #22c55e; border-radius: 9999px; transition: width 0.3s ease-in-out; } /* green-500 */
        progress::-moz-progress-bar { background-color: #22c55e; border-radius: 9999px; transition: width 0.3s ease-in-out; } /* green-500 */
        /* Canvas styling */
        canvas {
            display: block; width: 100%; height: 100%; /* Fill container */
            touch-action: none; background-color: white;
            border-radius: 0.5rem; border: 1px solid #e5e7eb; /* gray-200 */
            cursor: crosshair; /* Default cursor for drawing area */
        }
        /* Tooltip styling */
        .tooltip { position: relative; display: inline-block; cursor: help; }
        .tooltip .tooltiptext {
            visibility: hidden; width: 240px; background-color: #374151; /* gray-700 */
            color: #fff; text-align: center; border-radius: 6px; padding: 8px;
            position: absolute; z-index: 50; /* Ensure tooltip is on top */
            bottom: 125%; left: 50%; margin-left: -120px;
            opacity: 0; transition: opacity 0.3s; font-size: 0.875rem; /* text-sm */
            font-weight: normal; box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .tooltip:hover .tooltiptext { visibility: visible; opacity: 1; }
        /* Hide elements smoothly */
        .param-hidden { display: none; }
        /* Ensure canvas container takes up space */
        .canvas-container { min-height: 450px; height: 70vh; /* Increased height */ position: relative; }
        /* Style for target practice dots */
        .target-dot {
            position: absolute;
            border-radius: 50%;
            background-color: rgba(239, 68, 68, 0.7); /* Reddish */
            border: 2px solid rgba(239, 68, 68, 1);
            cursor: pointer;
            transition: transform 0.1s ease-out, background-color 0.1s ease-out;
        }
        .target-dot:hover {
             background-color: rgba(239, 68, 68, 0.9);
             transform: scale(1.1);
        }
        .target-dot.hit {
            background-color: rgba(34, 197, 94, 0.7); /* Greenish */
            border-color: rgba(34, 197, 94, 1);
            transform: scale(0.8);
            pointer-events: none; /* Disable further clicks */
        }

    </style>
</head>
<body class="bg-gray-100 text-gray-800">
    <div class="container mx-auto p-4 md:p-6 lg:p-8 max-w-screen-2xl">
        <header class="bg-white p-4 md:p-6 rounded-lg shadow-md mb-6 flex flex-col md:flex-row justify-between items-center gap-4">
            <h1 class="text-xl md:text-2xl lg:text-3xl font-bold text-blue-600 text-center md:text-left">专业数位板控笔训练系统</h1>
            <div class="flex flex-wrap items-center justify-center md:justify-end gap-4">
                 <div class="flex items-center gap-2">
                    <label for="modeSelect" class="text-sm font-medium whitespace-nowrap">模式:</label>
                    <select id="modeSelect" class="p-2 border border-gray-300 rounded-md shadow-sm text-sm focus:ring-blue-500 focus:border-blue-500">
                        <option value="practice">自由练习</option>
                        <option value="challenge">闯关模式</option>
                    </select>
                </div>
                <div id="challengeInfo" class="text-sm font-semibold text-purple-600 hidden whitespace-nowrap">
                    关卡: <span id="challengeLevel">1</span> | 目标: <span id="challengeTarget">-</span>
                </div>
                <div class="text-lg font-semibold text-blue-600 whitespace-nowrap">时间: <span id="timerDisplay">00:00</span></div>
            </div>
        </header>

        <div class="grid grid-cols-1 lg:grid-cols-4 gap-6">
            <div class="lg:col-span-1 bg-white p-5 rounded-lg shadow-md flex flex-col space-y-6 order-last lg:order-first">
                <div class="control-group">
                    <h3 class="text-lg font-semibold text-blue-600 border-b pb-2 mb-4">练习类型</h3>
                     <div>
                        <label for="exerciseType" class="sr-only">练习类型</label>
                        <select id="exerciseType" class="w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500">
                            <option value="straight">直线 (Straight Line)</option>
                            <option value="angled">角度线 (Angled Line)</option>
                            <option value="circle">圆形 (Circle)</option>
                            <option value="ellipse">椭圆 (Ellipse)</option>
                            <option value="square">方形 (Square)</option>
                            <option value="pressure">压力曲线 (Pressure Curve)</option>
                            <option value="smooth">平滑曲线 (Smooth Curve)</option>
                            <option value="zigzag">折线 (Zigzag)</option>
                            <option value="wave">波浪线 (Wave)</option>
                            <option value="spiral">螺旋线 (Spiral)</option>
                            <option value="random_curve">随机曲线 (Random Curve)</option> <option value="connect_dots">连接点 (Connect Dots)</option>
                            <option value="target_practice">目标点击 (Target Practice)</option> <option value="combined_shapes">形状组合 (Combined Shapes)</option> <option value="trace">图形描摹 (Trace Shape)</option>
                        </select>
                    </div>
                </div>

                <div id="parameterContainer" class="control-group">
                    <h3 class="text-lg font-semibold text-blue-600 border-b pb-2 mb-4">参数设置</h3>
                    <div id="params-general" class="space-y-3">
                         <div>
                            <label for="param-size" class="block text-sm font-medium text-gray-700 mb-1">大小/长度: <span id="param-size-value" class="font-mono">150</span></label>
                            <input type="range" id="param-size" min="50" max="500" value="150" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                        </div>
                    </div>
                    <div id="params-angled" class="space-y-3 param-hidden">
                        <div>
                            <label for="param-angle" class="block text-sm font-medium text-gray-700 mb-1">角度: <span id="param-angle-value" class="font-mono">45</span>°</label>
                            <input type="range" id="param-angle" min="0" max="180" value="45" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                        </div>
                    </div>
                     <div id="params-square" class="space-y-3 param-hidden">
                        <div>
                            <label for="param-corner_radius" class="block text-sm font-medium text-gray-700 mb-1">圆角半径: <span id="param-corner_radius-value" class="font-mono">0</span>px</label>
                            <input type="range" id="param-corner_radius" min="0" max="50" value="0" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                        </div>
                    </div>
                    <div id="params-ellipse" class="space-y-3 param-hidden">
                        <div>
                            <label for="param-ratio" class="block text-sm font-medium text-gray-700 mb-1">宽高比: <span id="param-ratio-value" class="font-mono">0.6</span></label>
                            <input type="range" id="param-ratio" min="0.2" max="1.0" step="0.1" value="0.6" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                        </div>
                    </div>
                    <div id="params-wave" class="space-y-3 param-hidden">
                        <div>
                            <label for="param-amplitude" class="block text-sm font-medium text-gray-700 mb-1">振幅/高度: <span id="param-amplitude-value" class="font-mono">50</span></label>
                            <input type="range" id="param-amplitude" min="10" max="150" value="50" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                        </div>
                         <div id="param-frequency-div"> <label for="param-frequency" class="block text-sm font-medium text-gray-700 mb-1">频率/复杂度: <span id="param-frequency-value" class="font-mono">3</span></label>
                            <input type="range" id="param-frequency" min="1" max="10" value="3" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                        </div>
                         <div>
                            <label for="param-smoothness" class="block text-sm font-medium text-gray-700 mb-1">转角平滑度: <span id="param-smoothness-value" class="font-mono">0.5</span></label>
                            <input type="range" id="param-smoothness" min="0" max="1" step="0.1" value="0.5" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                        </div>
                    </div>
                    <div id="params-spiral" class="space-y-3 param-hidden">
                         <div>
                            <label for="param-rotations" class="block text-sm font-medium text-gray-700 mb-1">圈数: <span id="param-rotations-value" class="font-mono">3</span></label>
                            <input type="range" id="param-rotations" min="1" max="8" value="3" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                        </div>
                         <div>
                            <label for="param-start_radius" class="block text-sm font-medium text-gray-700 mb-1">起始半径: <span id="param-start_radius-value" class="font-mono">5</span>px</label>
                            <input type="range" id="param-start_radius" min="0" max="50" value="5" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                        </div>
                    </div>
                    <div id="params-connect_dots" class="space-y-3 param-hidden">
                         <div>
                            <label for="param-dot_count" class="block text-sm font-medium text-gray-700 mb-1">点数: <span id="param-dot_count-value" class="font-mono">5</span></label>
                            <input type="range" id="param-dot_count" min="3" max="15" value="5" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                        </div>
                         <div>
                            <label for="param-dot_size" class="block text-sm font-medium text-gray-700 mb-1">点大小: <span id="param-dot_size-value" class="font-mono">10</span>px</label>
                            <input type="range" id="param-dot_size" min="5" max="25" value="10" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                        </div>
                         <div class="flex items-center">
                            <input type="checkbox" id="param-connect_sequential" checked class="h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500">
                            <label for="param-connect_sequential" class="ml-2 block text-sm text-gray-900">按顺序连接</label>
                        </div>
                    </div>
                    <div id="params-target_practice" class="space-y-3 param-hidden">
                         <div>
                            <label for="param-target_count" class="block text-sm font-medium text-gray-700 mb-1">目标数量: <span id="param-target_count-value" class="font-mono">10</span></label>
                            <input type="range" id="param-target_count" min="5" max="30" value="10" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                        </div>
                         <div>
                            <label for="param-target_size" class="block text-sm font-medium text-gray-700 mb-1">目标大小: <span id="param-target_size-value" class="font-mono">20</span>px</label>
                            <input type="range" id="param-target_size" min="10" max="40" value="20" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                        </div>
                    </div>
                    <div id="params-zigzag" class="space-y-3 param-hidden">
                         <div> <label for="param-segments" class="block text-sm font-medium text-gray-700 mb-1">段数: <span id="param-segments-value" class="font-mono">8</span></label>
                            <input type="range" id="param-segments" min="2" max="20" step="2" value="8" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                        </div>
                    </div>
                </div>

                <div class="control-group">
                     <h3 class="text-lg font-semibold text-blue-600 border-b pb-2 mb-4">通用设置</h3>
                     <div class="space-y-3">
                         <div>
                            <label for="lineWidth" class="block text-sm font-medium text-gray-700 mb-1">基础线条粗细: <span id="lineWidthValue" class="font-mono">5</span>px</label>
                            <input type="range" id="lineWidth" min="1" max="20" value="5" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                        </div>
                         <div>
                            <label for="fadeCount" class="block text-sm font-medium text-gray-700 mb-1">保留笔触数量: <span id="fadeCountValue" class="font-mono">10</span></label>
                            <input type="range" id="fadeCount" min="1" max="30" value="10" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                        </div>
                        <div class="flex items-center">
                            <input type="checkbox" id="showGuide" checked class="h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500">
                            <label for="showGuide" class="ml-2 block text-sm text-gray-900">显示参考线</label>
                        </div>
                        <div class="flex items-center">
                            <input type="checkbox" id="showHeatmap" checked class="h-4 w-4 text-red-600 border-gray-300 rounded focus:ring-red-500">
                            <label for="showHeatmap" class="ml-2 block text-sm text-gray-900">显示错误热力图</label>
                             <span class="tooltip ml-1">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 text-gray-500" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd" /></svg>
                                <span class="tooltiptext">显示历史绘制区域的累积偏差热图 (蓝色:低偏差, 黄色:中, 红色:高) - 体现区域性问题</span>
                            </span>
                        </div>
                         <div class="flex items-center">
                            <input type="checkbox" id="colorFeedback" class="h-4 w-4 text-purple-600 border-gray-300 rounded focus:ring-purple-500">
                            <label for="colorFeedback" class="ml-2 block text-sm text-gray-900">偏差颜色反馈</label>
                             <span class="tooltip ml-1">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 text-gray-500" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd" /></svg>
                                <span class="tooltiptext">根据离参考线的距离实时改变当前绘制线条颜色 (绿:近, 黄:中, 红:远) - 体现实时问题</span>
                            </span>
                        </div>
                         <div class="flex items-center"> </div>
                    </div>
                </div>

                <div class="control-group">
                    <h3 class="text-lg font-semibold text-blue-600 border-b pb-2 mb-4">练习控制</h3>
                    <div class="flex flex-wrap gap-2">
                        <button id="startBtn" class="px-4 py-2 bg-green-500 text-white rounded-md shadow hover:bg-green-600 transition duration-150 ease-in-out flex-grow">开始/下一关</button>
                        <button id="resetBtn" class="px-4 py-2 bg-yellow-500 text-white rounded-md shadow hover:bg-yellow-600 transition duration-150 ease-in-out">重置当前</button>
                        <button id="endChallengeBtn" class="px-4 py-2 bg-red-500 text-white rounded-md shadow hover:bg-red-600 transition duration-150 ease-in-out hidden">结束闯关</button>
                    </div>
                </div>

                <div class="exercise-progress">
                    <h3 class="text-lg font-semibold text-blue-600 border-b pb-2 mb-4">练习进度</h3>
                    <div class="mb-2">
                        <progress id="exerciseProgress" value="0" max="100" class="w-full"></progress>
                    </div>
                    <div class="flex justify-between text-sm text-gray-600">
                        <span>完成度: <span id="completionPercent" class="font-medium">0</span>%</span>
                        <span>尝试次数: <span id="attemptCount" class="font-medium">0</span></span>
                    </div>
                     <div id="targetPracticeProgress" class="text-sm text-gray-600 mt-1 hidden">
                        <span>击中目标: <span id="targetsHit" class="font-medium">0</span> / <span id="targetsTotal" class="font-medium">0</span></span>
                    </div>
                </div>
            </div>

            <div class="lg:col-span-3 bg-white p-1 rounded-lg shadow-md order-first lg:order-last">
                 <div class="canvas-container w-full h-full">
                    <canvas id="drawingCanvas"></canvas>
                    <div id="targetContainer" class="absolute inset-0 pointer-events-none"></div>
                    <div id="messageOverlay" class="absolute inset-0 bg-gray-900 bg-opacity-75 flex flex-col items-center justify-center text-white text-xl font-semibold rounded-lg pointer-events-none opacity-0 transition-opacity duration-300 p-4 text-center z-10">
                        <span id="messageText">请选择模式和练习类型，然后点击 "开始"</span>
                        <button id="messageBtn" class="mt-4 px-4 py-2 bg-blue-500 text-white rounded-md shadow hover:bg-blue-600 transition duration-150 ease-in-out text-base pointer-events-auto hidden">确定</button>
                    </div>
                </div>
            </div>
        </div>

        <div class="stats-panel bg-white p-5 rounded-lg shadow-md mt-6">
            <h3 class="text-lg font-semibold text-blue-600 border-b pb-2 mb-4">统计数据</h3>
            <div class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-8 gap-4 mb-6">
                <div class="stat-card bg-gray-50 p-3 rounded-lg border-l-4 border-blue-500">
                    <h4 class="text-sm font-medium text-gray-600 mb-1">当前压力</h4>
                    <p id="pressureValue" class="text-xl font-semibold text-gray-800">0.00</p>
                </div>
                <div class="stat-card bg-gray-50 p-3 rounded-lg border-l-4 border-purple-500">
                    <h4 class="text-sm font-medium text-gray-600 mb-1">笔倾斜角度</h4>
                    <p id="tiltValue" class="text-xl font-semibold text-gray-800">0°</p>
                </div>
                <div class="stat-card bg-gray-50 p-3 rounded-lg border-l-4 border-green-500">
                    <h4 class="text-sm font-medium text-gray-600 mb-1">线条平滑度</h4>
                    <p id="smoothnessValue" class="text-xl font-semibold text-gray-800">-</p>
                </div>
                <div class="stat-card bg-gray-50 p-3 rounded-lg border-l-4 border-yellow-500">
                    <h4 class="text-sm font-medium text-gray-600 mb-1">平均偏差</h4>
                    <p id="deviationValue" class="text-xl font-semibold text-gray-800">-</p>
                </div>
                 <div class="stat-card bg-gray-50 p-3 rounded-lg border-l-4 border-red-500">
                    <h4 class="text-sm font-medium text-gray-600 mb-1">抖动指数</h4>
                    <p id="jitterValue" class="text-xl font-semibold text-gray-800">-</p>
                </div>
                <div class="stat-card bg-gray-50 p-3 rounded-lg border-l-4 border-indigo-500">
                    <h4 class="text-sm font-medium text-gray-600 mb-1">平均速度</h4>
                    <p id="speedValue" class="text-xl font-semibold text-gray-800">-</p>
                </div>
                 <div class="stat-card bg-gray-50 p-3 rounded-lg border-l-4 border-cyan-500"> <h4 class="text-sm font-medium text-gray-600 mb-1">压力准确度</h4>
                    <p id="pressureAccuracyValue" class="text-xl font-semibold text-gray-800">-</p>
                </div>
                 <div class="stat-card bg-gray-50 p-3 rounded-lg border-l-4 border-pink-500">
                    <h4 class="text-sm font-medium text-gray-600 mb-1">本次得分</h4>
                    <p id="currentScoreValue" class="text-xl font-semibold text-gray-800">-</p>
                </div>
            </div>

            <div>
                <h4 class="text-md font-semibold text-gray-700 mb-2">历史记录</h4>
                 <div class="flex flex-col sm:flex-row justify-between text-sm text-gray-600 mb-1 gap-2 sm:gap-4">
                    <span>今日练习: <span id="todayExercises" class="font-medium">0</span> 次</span>
                    <span>练习总得分: <span id="totalScoreDisplay" class="font-medium">0</span></span>
                    <span>最高闯关: <span id="highestLevel" class="font-medium">0</span> 关</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- Utility Functions ---
        function distance(p1, p2) {
            if (!p1 || !p2) return 0;
            return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
        }

        function lerp(a, b, t) {
            return a + (b - a) * t;
        }

        // --- Main Application Class ---
        class DrawingTrainer {
            constructor() {
                // --- DOM Elements ---
                this.canvas = document.getElementById('drawingCanvas');
                this.ctx = this.canvas.getContext('2d', { willReadFrequently: true }); // Opt-in for performance if needed by heatmap
                this.targetContainer = document.getElementById('targetContainer'); // For target practice dots
                this.modeSelect = document.getElementById('modeSelect');
                this.exerciseTypeSelect = document.getElementById('exerciseType');
                this.parameterContainer = document.getElementById('parameterContainer');
                this.lineWidthSlider = document.getElementById('lineWidth');
                this.lineWidthValueSpan = document.getElementById('lineWidthValue');
                this.fadeCountSlider = document.getElementById('fadeCount'); // New slider for fade
                this.fadeCountValueSpan = document.getElementById('fadeCountValue'); // Display for fade count
                this.startBtn = document.getElementById('startBtn');
                this.resetBtn = document.getElementById('resetBtn');
                this.endChallengeBtn = document.getElementById('endChallengeBtn');
                this.showGuideCheckbox = document.getElementById('showGuide');
                this.showHeatmapCheckbox = document.getElementById('showHeatmap');
                this.colorFeedbackCheckbox = document.getElementById('colorFeedback');
                // Removed fadeStrokesCheckbox, now controlled by fadeCountSlider
                this.timerDisplay = document.getElementById('timerDisplay');
                this.pressureValueDisplay = document.getElementById('pressureValue');
                this.tiltValueDisplay = document.getElementById('tiltValue');
                this.smoothnessValueDisplay = document.getElementById('smoothnessValue');
                this.deviationValueDisplay = document.getElementById('deviationValue');
                this.jitterValueDisplay = document.getElementById('jitterValue');
                this.speedValueDisplay = document.getElementById('speedValue');
                this.pressureAccuracyValueDisplay = document.getElementById('pressureAccuracyValue'); // New stat display
                this.currentScoreValueDisplay = document.getElementById('currentScoreValue');
                this.exerciseProgress = document.getElementById('exerciseProgress');
                this.completionPercentDisplay = document.getElementById('completionPercent');
                this.attemptCountDisplay = document.getElementById('attemptCount');
                this.targetPracticeProgressDiv = document.getElementById('targetPracticeProgress'); // Target progress display
                this.targetsHitSpan = document.getElementById('targetsHit');
                this.targetsTotalSpan = document.getElementById('targetsTotal');
                this.todayExercisesDisplay = document.getElementById('todayExercises');
                this.totalScoreDisplay = document.getElementById('totalScoreDisplay');
                this.highestLevelDisplay = document.getElementById('highestLevel');
                this.messageOverlay = document.getElementById('messageOverlay');
                this.messageText = document.getElementById('messageText');
                this.messageBtn = document.getElementById('messageBtn');
                this.challengeInfoDiv = document.getElementById('challengeInfo');
                this.challengeLevelSpan = document.getElementById('challengeLevel');
                this.challengeTargetSpan = document.getElementById('challengeTarget');

                // Parameter Elements (Grouped for easier access)
                this.paramElements = {};
                this.paramDivs = {};
                this.parameterContainer.querySelectorAll('input[type="range"], input[type="checkbox"]').forEach(el => {
                    const key = el.id.replace('param-', ''); // e.g., 'size', 'angle', 'connect_sequential'
                    this.paramElements[key] = el;
                    const valueSpan = document.getElementById(el.id + '-value');
                    if (valueSpan) this.paramElements[`${key}Value`] = valueSpan;
                });
                this.parameterContainer.querySelectorAll('.space-y-3[id^="params-"]').forEach(div => {
                    const key = div.id.replace('params-', ''); // e.g., 'general', 'angled'
                    this.paramDivs[key] = div;
                });
                // Add frequency div separately as it's nested
                this.paramDivs.frequency = document.getElementById('param-frequency-div');


                // --- State Variables ---
                this.isDrawing = false;
                this.exerciseActive = false;
                this.currentMode = 'practice';
                this.currentExerciseType = 'straight';
                this.currentParams = {};
                this.showHeatmap = true;
                this.showGuide = true;
                this.colorFeedback = false;
                // this.fadeStrokes = true; // Now controlled by maxFadeStrokes > 0
                this.lineWidth = 5;
                this.lastPoint = { x: 0, y: 0, time: 0, pressure: 0.5, tiltX: 0, tiltY: 0, speed: 0, deviation: 0 };
                this.currentStroke = [];
                this.allStrokes = [];
                this.referencePath = null; // { points: [], totalLength: number, typeSpecificData: {} }
                this.deviationMap = null;
                this.attemptCount = 0;
                this.completionPercent = 0;
                this.currentScore = 0;
                this.startTime = 0;
                this.timerInterval = null;
                this.maxFadeStrokes = 10; // Default, controlled by slider

                // Target Practice State
                this.targets = []; // { x, y, size, hit, element }
                this.targetsHit = 0;

                // Statistics & History
                this.todayExercises = 0;
                this.totalScore = 0;
                this.highestLevelAchieved = 0;

                // Challenge Mode State
                this.challengeManager = new ChallengeModeManager();
                this.currentChallengeLevel = 0;
                this.currentChallengeDef = null;

                // Performance/Throttling
                this.lastRedrawTime = 0;
                this.redrawThrottle = 16; // ~60fps
                this.redrawPending = false; // Flag for throttled redraw
                this.resizeTimeout = null;

                // Bind methods
                Object.getOwnPropertyNames(Object.getPrototypeOf(this))
                    .filter(prop => typeof this[prop] === 'function' && prop !== 'constructor')
                    .forEach(method => { this[method] = this[method].bind(this); });

                // --- Initialization ---
                this.loadProgress();
                this.initUI();
                this.initEventListeners();
                this.updateParametersUI();
                this.resizeCanvas();
                this.showMessage("请选择模式和练习类型，然后点击 '开始/下一关'");
            }

            // --- Initialization & UI Setup ---

            initUI() {
                this.modeSelect.value = this.currentMode;
                this.exerciseTypeSelect.value = this.currentExerciseType;
                this.lineWidthSlider.value = this.lineWidth;
                this.lineWidthValueSpan.textContent = this.lineWidth;
                this.fadeCountSlider.value = this.maxFadeStrokes; // Set fade slider value
                this.fadeCountValueSpan.textContent = this.maxFadeStrokes; // Set fade display value
                this.showGuideCheckbox.checked = this.showGuide;
                this.showHeatmapCheckbox.checked = this.showHeatmap;
                this.colorFeedbackCheckbox.checked = this.colorFeedback;

                this.ensureDefaultParams();
                this.updateParamUIValues();

                this.updateModeUI();
                this.updateAttemptDisplay();
                this.updateCompletionDisplay();
                this.updateHistoryDisplay();
                this.updateScoreDisplay();
                this.updateTargetProgressDisplay(); // Hide initially
            }

            initEventListeners() {
                // Mode and Type Selectors
                this.modeSelect.addEventListener('change', (e) => this.setMode(e.target.value));
                this.exerciseTypeSelect.addEventListener('change', (e) => {
                    this.currentExerciseType = e.target.value;
                    this.ensureDefaultParams();
                    this.updateParametersUI();
                    if (this.currentMode === 'practice') {
                        this.prepareNewExercise(false);
                    }
                });

                // Canvas events (only drawing for non-target practice)
                this.canvas.addEventListener('pointerdown', (e) => {
                    if (this.currentExerciseType !== 'target_practice') this.handlePointerDown(e);
                });
                this.canvas.addEventListener('pointermove', (e) => {
                     if (this.currentExerciseType !== 'target_practice') this.handlePointerMove(e);
                 });
                this.canvas.addEventListener('pointerup', (e) => {
                     if (this.currentExerciseType !== 'target_practice') this.handlePointerUp(e);
                 });
                this.canvas.addEventListener('pointerleave', (e) => {
                     if (this.currentExerciseType !== 'target_practice') this.handlePointerUp(e);
                 });
                // Target container handles clicks for target practice
                this.targetContainer.addEventListener('pointerdown', (e) => {
                     if (this.currentExerciseType === 'target_practice' && e.target.classList.contains('target-dot')) {
                         this.handleTargetHit(e.target);
                     }
                 });


                // Control panel buttons
                this.startBtn.addEventListener('click', this.startOrContinueExercise);
                this.resetBtn.addEventListener('click', this.resetCurrentAttempt);
                this.endChallengeBtn.addEventListener('click', () => this.setMode('practice'));

                // General Settings Checkboxes & Sliders
                this.showGuideCheckbox.addEventListener('change', (e) => { this.showGuide = e.target.checked; this.requestRedraw(); this.saveProgress(); });
                this.showHeatmapCheckbox.addEventListener('change', (e) => { this.showHeatmap = e.target.checked; this.requestRedraw(); this.saveProgress(); });
                this.colorFeedbackCheckbox.addEventListener('change', (e) => { this.colorFeedback = e.target.checked; this.requestRedraw(); this.saveProgress(); });
                this.lineWidthSlider.addEventListener('input', (e) => {
                    this.lineWidth = parseInt(e.target.value);
                    this.lineWidthValueSpan.textContent = this.lineWidth;
                    this.saveProgress();
                });
                this.fadeCountSlider.addEventListener('input', (e) => { // Listener for fade count
                    this.maxFadeStrokes = parseInt(e.target.value);
                    this.fadeCountValueSpan.textContent = this.maxFadeStrokes;
                    this.requestRedraw(); // Redraw needed to apply new fading
                    this.saveProgress();
                });

                // Parameter Controls (Sliders and Checkboxes)
                for (const key in this.paramElements) {
                    const element = this.paramElements[key];
                    if (element.type === 'range') {
                        element.addEventListener('input', (e) => this.handleParamChange(key, e.target.value));
                    } else if (element.type === 'checkbox') {
                         element.addEventListener('change', (e) => this.handleParamChange(key, e.target.checked));
                    }
                }

                // Message Overlay Button
                this.messageBtn.addEventListener('click', this.handleMessageButtonClick); // Use separate handler

                // Window resize
                window.addEventListener('resize', this.handleResize);
            }

            handleMessageButtonClick() {
                const wasSuccess = this.messageOverlay.style.backgroundColor.includes('34, 197, 94'); // Check if it was green
                this.hideMessage();
                if (this.currentMode === 'challenge' && wasSuccess) {
                    // If challenge was successful, clicking OK starts next level
                    this.startChallengeLevel();
                }
            }


            handleParamChange(key, value) {
                const element = this.paramElements[key];
                const valueSpan = this.paramElements[`${key}Value`];
                let parsedValue = value;

                if (element.type === 'range') {
                    parsedValue = parseFloat(value);
                    if (element.step === "1" || !element.step) {
                        parsedValue = parseInt(value);
                    }
                    if (valueSpan) {
                         valueSpan.textContent = parsedValue.toFixed(element.step && element.step < 1 ? 1 : 0);
                    }
                } else if (element.type === 'checkbox') {
                    parsedValue = element.checked; // Value is boolean for checkbox
                }


                this.currentParams[key] = parsedValue;

                if (this.currentMode === 'practice' && this.exerciseActive) {
                    this.generateReferencePath();
                    this.allStrokes = [];
                    this.clearCanvasAndStats(false);
                    this.requestRedraw();
                }
                 this.saveProgress();
            }

            updateParametersUI() {
                Object.values(this.paramDivs).forEach(div => div?.classList.add('param-hidden'));

                const type = this.currentExerciseType;
                this.paramDivs.general?.classList.remove('param-hidden'); // Size always shown

                if (type === 'angled') this.paramDivs.angled?.classList.remove('param-hidden');
                if (type === 'square') this.paramDivs.square?.classList.remove('param-hidden');
                if (type === 'ellipse') this.paramDivs.ellipse?.classList.remove('param-hidden');
                if (['wave', 'smooth', 'zigzag', 'random_curve'].includes(type)) this.paramDivs.wave?.classList.remove('param-hidden');
                if (type === 'spiral') this.paramDivs.spiral?.classList.remove('param-hidden');
                if (type === 'connect_dots') this.paramDivs.connect_dots?.classList.remove('param-hidden');
                if (type === 'target_practice') this.paramDivs.target_practice?.classList.remove('param-hidden');
                if (type === 'zigzag') this.paramDivs.zigzag?.classList.remove('param-hidden');

                // Hide frequency for zigzag and random_curve
                if (this.paramDivs.frequency) {
                    this.paramDivs.frequency.style.display = (type === 'zigzag' || type === 'random_curve') ? 'none' : 'block';
                }
                 // Hide smoothness for random_curve
                 if (this.paramElements.smoothness) {
                    this.paramElements.smoothness.parentElement.style.display = (type === 'random_curve') ? 'none' : 'block';
                 }


                const disabled = this.currentMode === 'challenge';
                this.parameterContainer.querySelectorAll('input').forEach(input => input.disabled = disabled);
                this.exerciseTypeSelect.disabled = disabled;

                this.updateParamUIValues();
            }

             updateParamUIValues() {
                 for (const key in this.paramElements) {
                     const element = this.paramElements[key];
                     if (this.currentParams[key] !== undefined) {
                         if (element.type === 'range') {
                             element.value = this.currentParams[key];
                             const valueSpan = this.paramElements[`${key}Value`];
                             if (valueSpan) {
                                 valueSpan.textContent = Number(this.currentParams[key]).toFixed(element.step && element.step < 1 ? 1 : 0);
                             }
                         } else if (element.type === 'checkbox') {
                            element.checked = this.currentParams[key];
                         }
                     }
                 }
             }

             ensureDefaultParams() {
                 const defaults = {
                     size: 150, angle: 45, ratio: 0.6, amplitude: 50, frequency: 3,
                     rotations: 3, dot_count: 5, segments: 8, corner_radius: 0,
                     start_radius: 5, dot_size: 10, connect_sequential: true,
                     target_count: 10, target_size: 20, smoothness: 0.5
                 };
                 const relevantKeys = this.getRelevantParamKeys(this.currentExerciseType);
                 relevantKeys.push('size'); // Always include size

                 for (const key of Object.keys(defaults)) { // Iterate through all possible defaults
                     if (relevantKeys.includes(key) && this.currentParams[key] === undefined) {
                         this.currentParams[key] = defaults[key];
                     }
                 }
             }

            getRelevantParamKeys(type) {
                 // Returns keys relevant to the type, excluding 'size' which is always relevant
                 switch (type) {
                    case 'angled': return ['angle'];
                    case 'square': return ['corner_radius'];
                    case 'ellipse': return ['ratio'];
                    case 'wave':
                    case 'smooth': return ['amplitude', 'frequency', 'smoothness'];
                    case 'random_curve': return ['amplitude', 'frequency']; // Uses wave params
                    case 'spiral': return ['rotations', 'start_radius'];
                    case 'connect_dots': return ['dot_count', 'dot_size', 'connect_sequential'];
                    case 'target_practice': return ['target_count', 'target_size'];
                    case 'zigzag': return ['amplitude', 'segments', 'smoothness'];
                    default: return []; // straight, circle, pressure, trace, combined_shapes only use 'size'
                 }
            }

            setMode(mode) {
                if (this.currentMode === mode) return;
                this.currentMode = mode;
                this.updateModeUI();
                this.prepareNewExercise(true);
                this.saveProgress();
            }

            updateModeUI() {
                if (this.currentMode === 'practice') {
                    this.challengeInfoDiv.classList.add('hidden');
                    this.startBtn.textContent = '开始练习';
                    this.endChallengeBtn.classList.add('hidden');
                    this.resetBtn.disabled = false;
                    this.updateParametersUI();
                } else {
                    this.challengeInfoDiv.classList.remove('hidden');
                    this.startBtn.textContent = '开始挑战 / 下一关';
                    this.endChallengeBtn.classList.remove('hidden');
                    this.resetBtn.disabled = true;
                    this.currentChallengeLevel = this.highestLevelAchieved;
                    this.updateChallengeInfo();
                    this.updateParametersUI();
                }
            }

            updateChallengeInfo() {
                 this.challengeLevelSpan.textContent = this.currentChallengeLevel + 1;
                 this.currentChallengeDef = this.challengeManager.getLevelDefinition(this.currentChallengeLevel);
                 if (this.currentChallengeDef) {
                    this.startBtn.disabled = false; // Enable start button for next level
                    this.challengeTargetSpan.textContent = `类型: ${this.getExerciseTypeName(this.currentChallengeDef.type)}, 分数 > ${this.currentChallengeDef.targetScore}`;
                 } else {
                     this.challengeTargetSpan.textContent = "已通关!";
                     this.startBtn.disabled = true;
                 }
            }

             getExerciseTypeName(typeKey) {
                const option = this.exerciseTypeSelect.querySelector(`option[value="${typeKey}"]`);
                return option ? option.textContent.split('(')[0].trim() : typeKey;
            }


            // --- Canvas & Drawing Logic ---

            resizeCanvas() {
                const container = this.canvas.parentElement;
                const dpr = window.devicePixelRatio || 1;
                const rect = container.getBoundingClientRect();

                this.canvas.width = rect.width * dpr;
                this.canvas.height = rect.height * dpr;
                this.canvas.style.width = `${rect.width}px`;
                this.canvas.style.height = `${rect.height}px`;
                this.ctx.scale(dpr, dpr);

                // Adjust target dot positions if target practice is active
                if (this.exerciseActive && this.currentExerciseType === 'target_practice') {
                    this.generateTargets(); // Regenerate targets based on new size
                } else if (this.exerciseActive) {
                    this.generateReferencePath(); // Regenerate path for other types
                }
                this.requestRedraw();
            }

            handleResize() {
                clearTimeout(this.resizeTimeout);
                this.resizeTimeout = setTimeout(this.resizeCanvas, 200);
            }

            handlePointerDown(e) {
                if (!this.exerciseActive || e.button !== 0 || this.currentExerciseType === 'target_practice') return;
                this.isDrawing = true;
                const point = this.getPointFromEvent(e);
                point.deviation = this.getDeviationAtPoint(point);
                point.speed = 0;
                this.lastPoint = { ...point, time: Date.now() };
                this.currentStroke = [this.lastPoint];
                this.updateLiveStats(this.lastPoint);
                e.preventDefault();
            }

            handlePointerMove(e) {
                 if (!this.isDrawing || this.currentExerciseType === 'target_practice') return;
                 const currentTime = Date.now();
                 if (currentTime - this.lastPoint.time < 8) return;

                 const point = this.getPointFromEvent(e);
                 const timeDelta = currentTime - this.lastPoint.time;
                 const distanceMoved = distance(this.lastPoint, point); // Use utility function
                 point.speed = timeDelta > 0 ? distanceMoved / (timeDelta / 1000) : this.lastPoint.speed;
                 point.deviation = this.getDeviationAtPoint(point);

                 this.currentStroke.push(point);
                 this.lastPoint = { ...point, time: currentTime };
                 this.updateLiveStats(point);
                 this.requestRedraw(); // Request redraw to show real-time stroke
                 e.preventDefault();
            }

            handlePointerUp(e) {
                if (!this.isDrawing || this.currentExerciseType === 'target_practice') {
                    this.isDrawing = false; return; // Ensure isDrawing is false
                }
                this.isDrawing = false;

                if (this.currentStroke.length > 1) {
                    this.allStrokes.push([...this.currentStroke]);
                     // Apply fading limit
                    const fadeLimit = this.maxFadeStrokes > 0 ? this.maxFadeStrokes * 2 : 50; // Keep more if fading enabled
                    if (this.allStrokes.length > fadeLimit) {
                        this.allStrokes.splice(0, this.allStrokes.length - fadeLimit);
                    }
                }
                this.currentStroke = []; // Clear current stroke buffer

                this.calculateCompletion();
                this.updateOverallStats();
                if (this.showHeatmap) {
                    this.calculateDeviationMap();
                }
                this.requestRedraw();

                // Check completion threshold (for non-target practice)
                const requiredCompletion = this.currentChallengeDef?.completionThreshold ?? 95;
                if (this.completionPercent >= requiredCompletion) {
                    this.completeExercise();
                }
            }

            getPointFromEvent(e) {
                const rect = this.canvas.getBoundingClientRect();
                // No need to scale by DPR here if ctx is already scaled
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const pressure = e.pressure !== undefined ? e.pressure : 0.5;
                const tiltX = e.tiltX !== undefined ? e.tiltX : 0;
                const tiltY = e.tiltY !== undefined ? e.tiltY : 0;
                return { x, y, pressure, tiltX, tiltY };
            }

            requestRedraw() {
                if (!this.redrawPending) {
                    this.redrawPending = true;
                    requestAnimationFrame(() => {
                        this.redrawCanvas();
                        this.redrawPending = false;
                    });
                }
            }

            redrawCanvas() {
                 const dpr = window.devicePixelRatio || 1;
                 const canvasWidth = this.canvas.width / dpr;
                 const canvasHeight = this.canvas.height / dpr;
                 this.ctx.clearRect(0, 0, canvasWidth, canvasHeight);

                // --- Drawing Order ---
                // 1. Heatmap
                if (this.showHeatmap && this.deviationMap && this.currentExerciseType !== 'target_practice') {
                    this.drawHeatmap();
                }
                // 2. User Strokes (including current stroke for real-time feedback)
                if (this.currentExerciseType !== 'target_practice') {
                   this.drawUserStrokes();
                }
                // 3. Reference Path
                if (this.showGuide && this.referencePath && this.currentExerciseType !== 'target_practice') {
                    this.drawReference();
                }
                // 4. Pressure Guide Text
                if (this.exerciseActive && this.currentExerciseType === 'pressure' && this.showGuide) {
                    this.drawPressureGuideText();
                }
                 // 5. Connect Dots Info
                 if (this.exerciseActive && this.currentExerciseType === 'connect_dots' && this.showGuide && this.referencePath?.typeSpecificData?.dots) {
                    this.drawConnectDotsInfo();
                 }
                 // NOTE: Target dots are HTML elements, not drawn on canvas
            }

            drawUserStrokes() {
                this.ctx.lineCap = 'round';
                this.ctx.lineJoin = 'round';
                const numStrokes = this.allStrokes.length;
                const fadeStartIdx = this.maxFadeStrokes > 0 ? Math.max(0, numStrokes - this.maxFadeStrokes) : numStrokes; // Index where fading begins

                // Draw completed strokes with fading
                for (let strokeIndex = 0; strokeIndex < numStrokes; strokeIndex++) {
                    const stroke = this.allStrokes[strokeIndex];
                    if (stroke.length < 2) continue;

                    let alpha = 1.0;
                    if (this.maxFadeStrokes > 0 && strokeIndex < fadeStartIdx) {
                        const fadeRange = fadeStartIdx > 0 ? fadeStartIdx : 1;
                        alpha = Math.max(0.05, 1.0 - (fadeStartIdx - strokeIndex) * (0.95 / fadeRange));
                    }

                    let lastPoint = stroke[0];
                    for (let i = 1; i < stroke.length; i++) {
                        const currentPoint = stroke[i];
                        this.drawSingleSegment(lastPoint, currentPoint, alpha);
                        lastPoint = currentPoint;
                    }
                }

                // Draw the current stroke (real-time) without fading
                if (this.currentStroke.length > 1) {
                    let lastPoint = this.currentStroke[0];
                    for (let i = 1; i < this.currentStroke.length; i++) {
                        const currentPoint = this.currentStroke[i];
                        this.drawSingleSegment(lastPoint, currentPoint, 1.0); // Alpha = 1.0
                        lastPoint = currentPoint;
                    }
                }
            }

            // Helper to draw a single line segment with specific style and alpha
            drawSingleSegment(p1, p2, alpha) {
                 let r=51, g=51, b=51; // Default gray
                 if (this.colorFeedback) {
                     const dev = p2.deviation; // Use deviation of the end point
                     const lowThresh = this.lineWidth * 0.8;
                     const highThresh = this.lineWidth * 2.5;
                     if (dev < lowThresh) { r=34; g=197; b=94; } // green
                     else if (dev < highThresh) { r=234; g=179; b=8; } // yellow
                     else { r=239; g=68; b=68; } // red
                 }
                 const strokeStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;
                 this.ctx.lineWidth = Math.max(1, this.lineWidth * p1.pressure); // Use pressure of start point
                 this.ctx.strokeStyle = strokeStyle;
                 this.ctx.beginPath();
                 this.ctx.moveTo(p1.x, p1.y);
                 this.ctx.lineTo(p2.x, p2.y);
                 this.ctx.stroke();
            }


            drawReference() {
                if (!this.referencePath || !this.referencePath.points || this.referencePath.points.length < 1) return;
                const points = this.referencePath.points;
                this.ctx.lineWidth = 1.5;
                this.ctx.strokeStyle = 'rgba(66, 133, 244, 0.7)';
                this.ctx.setLineDash([4, 4]);
                this.ctx.beginPath();

                let moved = false;
                for (let i = 0; i < points.length; i++) {
                    const p = points[i];
                    if (p === null) { moved = false; }
                    else {
                        if (!moved) { this.ctx.moveTo(p.x, p.y); moved = true; }
                        else { this.ctx.lineTo(p.x, p.y); }
                    }
                }
                this.ctx.stroke();
                this.ctx.setLineDash([]);
            }

            drawConnectDotsInfo() {
                const dots = this.referencePath.typeSpecificData.dots;
                if (!dots) return;
                const dpr = window.devicePixelRatio || 1;
                const baseFontSize = this.currentParams.dot_size ? this.currentParams.dot_size * 0.8 : 10; // Base font on dot size
                const fontSize = Math.min(20, Math.max(8, baseFontSize * (this.canvas.width / dpr / 800)));
                this.ctx.font = `bold ${fontSize}px ${getComputedStyle(document.body).fontFamily}`;
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                const targetRadius = this.currentParams.dot_size ? this.currentParams.dot_size / 2 : 5;

                dots.forEach((dot, index) => {
                    this.ctx.beginPath();
                    this.ctx.arc(dot.x, dot.y, targetRadius, 0, Math.PI * 2);
                    this.ctx.fillStyle = 'rgba(59, 130, 246, 0.15)';
                    this.ctx.fill();
                    this.ctx.lineWidth = 1;
                    this.ctx.strokeStyle = 'rgba(59, 130, 246, 0.5)';
                    this.ctx.stroke();
                    this.ctx.fillStyle = '#1e40af';
                    this.ctx.fillText(index + 1, dot.x, dot.y);
                });
                 this.ctx.textAlign = 'start';
                 this.ctx.textBaseline = 'alphabetic';
            }


             drawPressureGuideText() {
                 const dpr = window.devicePixelRatio || 1;
                 const margin = this.getMargin();
                 const canvasWidth = this.canvas.width / dpr;
                 const canvasHeight = this.canvas.height / dpr;
                 const midY = canvasHeight / 2;
                 this.ctx.font = '14px ' + getComputedStyle(document.body).fontFamily;
                 this.ctx.fillStyle = '#4285f4';
                 this.ctx.textAlign = 'left';
                 this.ctx.fillText('轻压', margin, midY - 60);
                 this.ctx.textAlign = 'right';
                 this.ctx.fillText('重压', canvasWidth - margin, midY + 70);
                 this.ctx.textAlign = 'start';
             }

            drawHeatmap() {
                 if (!this.deviationMap) return;
                 const dpr = window.devicePixelRatio || 1;
                 const mapWidth = this.canvas.width; const mapHeight = this.canvas.height;
                 const canvasDrawWidth = mapWidth / dpr; const canvasDrawHeight = mapHeight / dpr;

                 // Create ImageData matching the canvas buffer size
                 const imageData = this.ctx.createImageData(mapWidth, mapHeight);
                 const data = imageData.data;
                 const maxDeviationHeat = 30;

                 for (let y = 0; y < mapHeight; y++) {
                     for (let x = 0; x < mapWidth; x++) {
                         const index = y * mapWidth + x;
                         const deviation = this.deviationMap[index]; // Deviation map stores values directly

                         if (deviation > 0.1) {
                             const t = Math.min(deviation / maxDeviationHeat, 1);
                             let r, g, b;
                             if (t < 0.5) { const t2=t*2; r=59*(1-t2)+234*t2; g=130*(1-t2)+179*t2; b=246*(1-t2)+8*t2; }
                             else { const t2=(t-0.5)*2; r=234*(1-t2)+239*t2; g=179*(1-t2)+68*t2; b=8*(1-t2)+68*t2; }
                             const alpha = Math.floor(40 + t * 100);

                             const dataIndex = index * 4;
                             data[dataIndex] = Math.floor(r); data[dataIndex+1] = Math.floor(g); data[dataIndex+2] = Math.floor(b); data[dataIndex+3] = alpha;
                         }
                     }
                 }
                 // Use a temporary canvas for performance
                 const tempCanvas = document.createElement('canvas');
                 tempCanvas.width = mapWidth; tempCanvas.height = mapHeight;
                 const tempCtx = tempCanvas.getContext('2d');
                 tempCtx.putImageData(imageData, 0, 0);
                 // Draw the temp canvas onto the main canvas, scaling down to CSS pixels
                 this.ctx.drawImage(tempCanvas, 0, 0, canvasDrawWidth, canvasDrawHeight);
            }

            // --- Exercise Logic ---

            showMessage(text, showButton = false, isSuccess = null, autoAdvanceDelay = null) {
                this.messageText.textContent = text;
                this.messageOverlay.style.opacity = '1';
                this.messageOverlay.style.pointerEvents = 'auto';
                let bgColor = 'rgba(55, 65, 81, 0.8)'; // Default gray
                if (isSuccess === true) bgColor = 'rgba(34, 197, 94, 0.8)'; // Greenish
                else if (isSuccess === false) bgColor = 'rgba(239, 68, 68, 0.8)'; // Reddish
                this.messageOverlay.style.backgroundColor = bgColor;

                this.messageBtn.style.display = showButton ? 'inline-block' : 'none';
                this.messageBtn.onclick = this.handleMessageButtonClick; // Use bound handler

                // Clear previous auto-advance timer if any
                if (this.autoAdvanceTimer) clearTimeout(this.autoAdvanceTimer);

                // Set new auto-advance timer if needed
                if (autoAdvanceDelay && isSuccess === true && this.currentMode === 'challenge') {
                    this.autoAdvanceTimer = setTimeout(() => {
                        this.hideMessage();
                        this.startChallengeLevel(); // Automatically start next level
                    }, autoAdvanceDelay);
                }
            }

            hideMessage() {
                this.messageOverlay.style.opacity = '0';
                this.messageOverlay.style.pointerEvents = 'none';
                 if (this.autoAdvanceTimer) { // Clear timer if message is hidden manually
                    clearTimeout(this.autoAdvanceTimer);
                    this.autoAdvanceTimer = null;
                 }
            }

            startOrContinueExercise() {
                 this.startBtn.disabled = true;
                 if (this.currentMode === 'practice') {
                    this.startPracticeExercise();
                 } else {
                    this.startChallengeLevel();
                 }
                 setTimeout(() => { this.startBtn.disabled = false; }, 300); // Shorter delay
            }

            startPracticeExercise() {
                this.exerciseActive = true;
                this.attemptCount = 0;
                this.completionPercent = 0;
                this.currentScore = 0;
                this.allStrokes = [];
                this.deviationMap = null;
                this.hideMessage();
                this.clearTargets(); // Clear target practice elements if any
                this.targetPracticeProgressDiv.classList.add('hidden'); // Hide target progress
                this.canvas.style.display = 'block'; // Ensure canvas is visible

                if (this.currentExerciseType === 'target_practice') {
                    this.canvas.style.display = 'none'; // Hide canvas for target practice
                    this.generateTargets();
                } else {
                   this.generateReferencePath();
                }

                this.clearCanvasAndStats();
                this.updateAttemptDisplay();
                this.updateCompletionDisplay();
                this.updateScoreDisplay();
                this.startTimer();
                this.requestRedraw(); // Initial draw
            }

            startChallengeLevel() {
                 this.currentChallengeDef = this.challengeManager.getLevelDefinition(this.currentChallengeLevel);
                 if (!this.currentChallengeDef) {
                     this.showMessage("恭喜！您已完成所有挑战关卡！", true, true);
                     this.setMode('practice');
                     return;
                 }
                 this.exerciseActive = true;
                 this.attemptCount = 0;
                 this.completionPercent = 0;
                 this.currentScore = 0;
                 this.allStrokes = [];
                 this.deviationMap = null;
                 this.hideMessage();
                 this.clearTargets();
                 this.targetPracticeProgressDiv.classList.add('hidden');
                 this.canvas.style.display = 'block';

                 this.currentExerciseType = this.currentChallengeDef.type;
                 this.currentParams = { ...this.currentChallengeDef.params };
                 this.exerciseTypeSelect.value = this.currentExerciseType;
                 this.updateParamUIValues();
                 this.updateChallengeInfo();

                 if (this.currentExerciseType === 'target_practice') {
                    this.canvas.style.display = 'none';
                    this.generateTargets();
                 } else {
                    this.generateReferencePath();
                 }

                 this.clearCanvasAndStats();
                 this.updateAttemptDisplay();
                 this.updateCompletionDisplay();
                 this.updateScoreDisplay();
                 this.startTimer();
                 this.requestRedraw();
            }


            resetCurrentAttempt() {
                if (!this.exerciseActive || this.currentMode === 'challenge') return;

                this.attemptCount++;
                this.completionPercent = 0;
                this.currentScore = 0;
                this.allStrokes = [];
                this.deviationMap = null;
                this.clearTargets(); // Clear targets if it's target practice
                this.clearCanvasAndStats(false);
                this.updateAttemptDisplay();
                this.updateCompletionDisplay();
                this.updateScoreDisplay();

                 // Regenerate if needed (e.g., target practice)
                 if (this.currentExerciseType === 'target_practice') {
                    this.generateTargets();
                 } else {
                    this.requestRedraw();
                 }
            }

            prepareNewExercise(resetHistory = true) {
                this.exerciseActive = false;
                this.isDrawing = false;
                this.canvas.style.cursor = 'crosshair'; // Reset cursor
                this.stopTimer();
                this.timerDisplay.textContent = '00:00';
                this.clearCanvasAndStats(resetHistory);
                this.referencePath = null;
                this.clearTargets();
                this.targetPracticeProgressDiv.classList.add('hidden');
                this.canvas.style.display = 'block'; // Ensure canvas visible by default
                this.requestRedraw();

                 if (this.currentMode === 'practice') {
                    this.showMessage("请点击 '开始练习'");
                 } else {
                    this.updateChallengeInfo();
                    this.showMessage(`准备挑战第 ${this.currentChallengeLevel + 1} 关`);
                 }

                if (resetHistory) {
                    this.attemptCount = 0;
                    this.completionPercent = 0;
                    this.currentScore = 0;
                    this.updateAttemptDisplay();
                    this.updateCompletionDisplay();
                    this.updateScoreDisplay();
                }
            }

            completeExercise() {
                 if (!this.exerciseActive) return;
                 this.exerciseActive = false;
                 this.isDrawing = false;
                 this.stopTimer();

                 const timeTaken = (Date.now() - this.startTime) / 1000;
                 let finalStats = {};

                 if (this.currentExerciseType === 'target_practice') {
                    // Score based on hit rate and time
                    const hitRate = this.targets.length > 0 ? this.targetsHit / this.targets.length : 0;
                    const timePenalty = Math.max(0, timeTaken - this.targets.length * 0.5); // Penalize time beyond 0.5s per target
                    this.currentScore = Math.max(0, Math.floor(hitRate * 100 - timePenalty * 2));
                    // No deviation/jitter stats for target practice
                    this.smoothnessValueDisplay.textContent = '-';
                    this.deviationValueDisplay.textContent = '-';
                    this.jitterValueDisplay.textContent = '-';
                    this.pressureAccuracyValueDisplay.textContent = '-';
                 } else {
                    finalStats = this.calculateOverallStats();
                    this.currentScore = this.calculateScore(finalStats, timeTaken);
                 }

                 this.updateScoreDisplay();
                 this.todayExercises++;
                 this.totalScore += this.currentScore;
                 this.updateHistoryDisplay();

                 if (this.currentMode === 'practice') {
                    this.showMessage(`练习完成! 本次得分: ${this.currentScore}`, true, true);
                    this.saveProgress();
                 } else {
                     const targetScore = this.currentChallengeDef.targetScore;
                     const success = this.currentScore >= targetScore;
                     if (success) {
                         this.currentChallengeLevel++; // Advance level immediately
                         if (this.currentChallengeLevel > this.highestLevelAchieved) {
                             this.highestLevelAchieved = this.currentChallengeLevel;
                         }
                         this.showMessage(`挑战成功! 得分: ${this.currentScore} (目标: ${targetScore}). 正在进入下一关...`, false, true, 1500); // Auto advance after 1.5s
                     } else {
                         this.showMessage(`挑战失败. 得分: ${this.currentScore} (目标: ${targetScore}). 点击 [确定] 重试本关`, true, false);
                     }
                     this.saveProgress(); // Save challenge progress
                 }
            }

             calculateScore(stats, timeTaken) {
                const avgDev = stats.avgDeviation || 0;
                const jit = stats.jitter || 0;
                const smooth = stats.smoothness || 0;
                const pressAcc = stats.pressureAccuracy || 0; // Use pressure accuracy if available

                // Base score components
                const deviationScore = Math.max(0, 100 - avgDev * 4);
                const jitterScore = Math.max(0, 100 - jit * 25);
                const smoothnessScore = smooth * 100;
                const pressureScore = pressAcc * 100; // Pressure accuracy score

                // Time factor
                const timeFactor = Math.max(0.1, 1 - (Math.max(0, timeTaken - 5) / 120));
                // Completion factor
                const completionFactor = this.completionPercent / 100;

                let score;
                // Weight pressure accuracy heavily for the pressure exercise
                if (this.currentExerciseType === 'pressure') {
                    score = (deviationScore * 0.2 + jitterScore * 0.1 + smoothnessScore * 0.1 + pressureScore * 0.6) * timeFactor * completionFactor;
                } else {
                    // Default weighting without pressure
                    score = (deviationScore * 0.45 + jitterScore * 0.35 + smoothnessScore * 0.2) * timeFactor * completionFactor;
                }

                return Math.max(0, Math.floor(score));
             }

            clearCanvasAndStats(fullReset = true) {
                const dpr = window.devicePixelRatio || 1;
                const canvasWidth = this.canvas.width / dpr;
                const canvasHeight = this.canvas.height / dpr;
                this.ctx.clearRect(0, 0, canvasWidth, canvasHeight);
                this.allStrokes = [];
                this.deviationMap = null;

                // Reset stats display
                this.pressureValueDisplay.textContent = '0.00';
                this.tiltValueDisplay.textContent = '0°';
                this.smoothnessValueDisplay.textContent = '-';
                this.deviationValueDisplay.textContent = '-';
                this.jitterValueDisplay.textContent = '-';
                this.speedValueDisplay.textContent = '-';
                this.pressureAccuracyValueDisplay.textContent = '-'; // Reset new stat
                this.currentScoreValueDisplay.textContent = '-';

                if (fullReset) {
                    this.completionPercent = 0;
                    this.attemptCount = 0;
                    this.currentScore = 0;
                    this.updateCompletionDisplay();
                    this.updateAttemptDisplay();
                    this.updateScoreDisplay();
                }
            }

            // --- Reference Path Generation ---

            getMargin() { return Math.min(this.canvas.width / (window.devicePixelRatio||1), this.canvas.height / (window.devicePixelRatio||1)) * 0.08; }

            generateReferencePath() {
                const points = [];
                const typeSpecificData = {};
                const dpr = window.devicePixelRatio || 1;
                const canvasWidth = this.canvas.width / dpr;
                const canvasHeight = this.canvas.height / dpr;
                const margin = this.getMargin();
                const centerX = canvasWidth / 2;
                const centerY = canvasHeight / 2;
                const availableWidth = canvasWidth - 2 * margin;
                const availableHeight = canvasHeight - 2 * margin;

                this.ensureDefaultParams();
                const params = this.currentParams;
                const step = 5; // Density for path points

                try {
                    switch (this.currentExerciseType) {
                         case 'straight': case 'angled': case 'circle': case 'ellipse':
                         case 'square': case 'spiral': case 'trace':
                             // Standard path generation (simplified examples)
                             this.generateStandardPath(points, typeSpecificData, params, centerX, centerY, availableWidth, availableHeight, step);
                             break;
                         case 'pressure':
                            this.generatePressurePath(points, typeSpecificData, params, centerX, centerY, availableWidth, availableHeight, step);
                            break;
                         case 'smooth': case 'wave': case 'random_curve': case 'zigzag':
                             this.generateCurvePath(points, typeSpecificData, params, centerX, centerY, availableWidth, availableHeight, step);
                             break;
                         case 'connect_dots':
                             this.generateConnectDotsPath(points, typeSpecificData, params, centerX, centerY, availableWidth, availableHeight, step, margin);
                             break;
                         case 'combined_shapes':
                             this.generateCombinedShapesPath(points, typeSpecificData, params, centerX, centerY, availableWidth, availableHeight, step);
                             break;
                         case 'target_practice':
                             // No path generated, handled by generateTargets()
                             break; // Skip path generation
                         default:
                             console.warn("Unknown exercise type for path generation:", this.currentExerciseType);
                    }
                } catch (error) {
                    console.error("Error generating reference path:", error);
                    this.showMessage("生成参考路径时出错。", false, false);
                    this.referencePath = { points: [], totalLength: 0, typeSpecificData: {} };
                    return;
                }

                // Only set path if not target practice
                if (this.currentExerciseType !== 'target_practice') {
                    this.referencePath = { points: points, totalLength: this.calculatePathLength(points), typeSpecificData };
                } else {
                    this.referencePath = null; // No path for target practice
                }
            }

            // --- Sub-functions for Path Generation ---

            generateStandardPath(points, data, params, cx, cy, availW, availH, step) {
                 const size = params.size;
                 switch (this.currentExerciseType) {
                    case 'straight':
                        const len = Math.min(size, availW); const startX = cx - len / 2;
                        for (let x = startX; x <= startX + len; x += step) points.push({ x, y: cy });
                        break;
                    case 'angled':
                        const rad = params.angle * Math.PI / 180;
                        let maxLen = availW;
                        if (Math.abs(Math.cos(rad)) > 1e-6) maxLen = Math.min(maxLen, availW / Math.abs(Math.cos(rad)));
                        if (Math.abs(Math.sin(rad)) > 1e-6) maxLen = Math.min(maxLen, availH / Math.abs(Math.sin(rad)));
                        const angLen = Math.min(size, maxLen);
                        const sX = cx - (angLen / 2) * Math.cos(rad); const sY = cy - (angLen / 2) * Math.sin(rad);
                        for (let i = 0; i <= angLen; i += step) points.push({ x: sX + i * Math.cos(rad), y: sY + i * Math.sin(rad) });
                        break;
                    case 'circle':
                        const r = Math.min(size / 2, availW / 2, availH / 2);
                        if (r < step) break;
                        for (let a = 0; a < Math.PI * 2; a += (step / r)) points.push({ x: cx + Math.cos(a) * r, y: cy + Math.sin(a) * r });
                        if (points.length > 0) points.push(points[0]);
                        break;
                    case 'ellipse':
                        const rx = Math.min(size / 2, availW / 2); const ry = Math.min(rx * params.ratio, availH / 2);
                        if (rx < step || ry < step) break;
                        for (let a = 0; a < Math.PI * 2; a += (step / Math.max(rx, ry))) points.push({ x: cx + Math.cos(a) * rx, y: cy + Math.sin(a) * ry });
                        if (points.length > 0) points.push(points[0]);
                        break;
                    case 'square':
                        const side = Math.min(size, availW, availH); const half = side / 2; const cr = Math.min(params.corner_radius, half);
                        const x0=cx-half, y0=cy-half, x1=cx+half, y1=cy+half;
                        if (cr <= 0) { // Sharp corners
                           for (let x = x0; x <= x1; x += step) points.push({ x, y: y0 }); for (let y = y0; y <= y1; y += step) points.push({ x: x1, y });
                           for (let x = x1; x >= x0; x -= step) points.push({ x, y: y1 }); for (let y = y1; y >= y0; y -= step) points.push({ x: x0, y });
                        } else { // Rounded corners
                            for (let a = Math.PI * 1.5; a <= Math.PI * 2; a += (step / cr)) points.push({ x: x1 - cr + Math.cos(a) * cr, y: y0 + cr + Math.sin(a) * cr }); // Top right
                            for (let a = 0; a <= Math.PI * 0.5; a += (step / cr)) points.push({ x: x1 - cr + Math.cos(a) * cr, y: y1 - cr + Math.sin(a) * cr }); // Bottom right
                            for (let a = Math.PI * 0.5; a <= Math.PI; a += (step / cr)) points.push({ x: x0 + cr + Math.cos(a) * cr, y: y1 - cr + Math.sin(a) * cr }); // Bottom left
                            for (let a = Math.PI; a <= Math.PI * 1.5; a += (step / cr)) points.push({ x: x0 + cr + Math.cos(a) * cr, y: y0 + cr + Math.sin(a) * cr }); // Top left
                        }
                        if (points.length > 0) points.push(points[0]);
                        break;
                    case 'spiral':
                        const maxR = Math.min(size / 2, availW / 2, availH / 2); const startR = params.start_radius;
                        const totalAngle = params.rotations * Math.PI * 2;
                        for (let a = 0; a <= totalAngle; a += 0.1) {
                            const r = startR + (maxR - startR) * (a / totalAngle); // Linear growth from startR
                            points.push({ x: cx + Math.cos(a) * r, y: cy + Math.sin(a) * r });
                        }
                        break;
                    case 'trace': // Simple house shape
                         const houseW = size * 0.8; const houseH = size * 0.7; const roofH = houseH * 0.5;
                         const hX=cx-houseW/2, hY=cy-houseH/2;
                         const housePoints = [ {x: hX, y: hY + houseH}, {x: hX + houseW, y: hY + houseH}, {x: hX + houseW, y: hY}, {x: cx, y: hY - roofH}, {x: hX, y: hY}, {x: hX, y: hY + houseH} ];
                         points.push(...this.densifyPath(housePoints, step)); // Use densify directly
                         break;
                 }
            }

            generatePressurePath(points, data, params, cx, cy, availW, availH, step) {
                const pLength = Math.min(params.size * 1.5, availW);
                const pHeight = availH * 0.3;
                const pStartX = cx - pLength / 2;
                data.targetPressures = []; // Store target pressure along the path

                for (let x = pStartX; x <= pStartX + pLength; x += step) {
                    const progress = (x - pStartX) / pLength; // 0 to 1
                    // Target pressure: 0.1 -> 0.9 -> 0.1 (using a sine-like curve for pressure)
                    const targetPressure = 0.1 + 0.8 * Math.sin(progress * Math.PI);
                    // Y offset using tanh curve
                    const yOffset = (Math.tanh((progress - 0.5) * 6) + 1) / 2 * pHeight;
                    points.push({ x: x, y: cy - pHeight / 2 + yOffset, targetPressure: targetPressure });
                }
            }

            generateCurvePath(points, data, params, cx, cy, availW, availH, step) {
                const cLength = Math.min(params.size * 1.5, availW);
                const cAmp = Math.min(params.amplitude, availH / 2);
                const cFreq = params.frequency;
                const cStartX = cx - cLength / 2;
                const cSmooth = params.smoothness ?? 0.5; // Corner smoothing for zigzag

                switch (this.currentExerciseType) {
                    case 'smooth': case 'wave':
                        for (let x = cStartX; x <= cStartX + cLength; x += step) {
                            const progress = (x - cStartX) / cLength;
                            const y = cy + Math.sin(progress * Math.PI * 2 * cFreq) * cAmp;
                            points.push({ x: x, y: y });
                        }
                        break;
                    case 'random_curve':
                        // Simple random curve using waypoints and Catmull-Rom interpolation
                        const numPoints = Math.floor(cFreq * 2) + 2; // Use frequency for complexity
                        const waypoints = [];
                        for (let i = 0; i < numPoints; i++) {
                            waypoints.push({
                                x: cStartX + (i / (numPoints - 1)) * cLength,
                                y: cy + (Math.random() - 0.5) * cAmp * 2
                            });
                        }
                        // Add control points for Catmull-Rom
                        const ctrlPoints = [waypoints[0], ...waypoints, waypoints[numPoints - 1]];
                        for (let i = 1; i < ctrlPoints.length - 2; i++) {
                            const p0 = ctrlPoints[i-1], p1 = ctrlPoints[i], p2 = ctrlPoints[i+1], p3 = ctrlPoints[i+2];
                            for (let t = 0; t < 1; t += 0.1) { // Density of interpolation
                                const t2 = t * t, t3 = t2 * t;
                                const x = 0.5 * ((2 * p1.x) + (-p0.x + p2.x) * t + (2 * p0.x - 5 * p1.x + 4 * p2.x - p3.x) * t2 + (-p0.x + 3 * p1.x - 3 * p2.x + p3.x) * t3);
                                const y = 0.5 * ((2 * p1.y) + (-p0.y + p2.y) * t + (2 * p0.y - 5 * p1.y + 4 * p2.y - p3.y) * t2 + (-p0.y + 3 * p1.y - 3 * p2.y + p3.y) * t3);
                                points.push({ x, y });
                            }
                        }
                         points.push(waypoints[numPoints - 1]); // Ensure last point is added
                        break;
                     case 'zigzag':
                         const zSegments = Math.max(2, Math.floor(params.segments / 2) * 2);
                         const segWidth = cLength / zSegments;
                         let curX = cStartX; let curY = cy;
                         const corners = [{ x: curX, y: curY }];
                         for (let i = 0; i < zSegments; i++) {
                             curX += segWidth;
                             curY = (i % 2 === 0) ? cy - cAmp / 2 : cy + cAmp / 2;
                             corners.push({ x: curX, y: curY });
                         }
                         // Apply smoothing using Chaikin's algorithm or similar based on cSmooth
                         if (cSmooth > 0 && corners.length > 2) {
                            let smoothed = corners;
                            const iterations = Math.floor(cSmooth * 5); // More iterations for smoother curves
                            for (let iter = 0; iter < iterations; iter++) {
                                const nextSmoothed = [smoothed[0]]; // Keep first point
                                for (let i = 0; i < smoothed.length - 1; i++) {
                                    const p0 = smoothed[i]; const p1 = smoothed[i+1];
                                    // Add two new points replacing the segment
                                    nextSmoothed.push({ x: lerp(p0.x, p1.x, 0.25), y: lerp(p0.y, p1.y, 0.25) });
                                    nextSmoothed.push({ x: lerp(p0.x, p1.x, 0.75), y: lerp(p0.y, p1.y, 0.75) });
                                }
                                nextSmoothed.push(smoothed[smoothed.length - 1]); // Keep last point
                                smoothed = nextSmoothed;
                            }
                            points.push(...this.densifyPath(smoothed, step));
                         } else {
                            points.push(...this.densifyPath(corners, step)); // Use sharp corners
                         }
                         break;
                }
            }

             generateConnectDotsPath(points, data, params, cx, cy, availW, availH, step, margin) {
                const dots = [];
                const connectRadius = Math.min(params.size, availW / 2, availH / 2);
                for (let i = 0; i < params.dot_count; i++) {
                    const angle = (i / params.dot_count) * Math.PI * 2 + (Math.random() - 0.5) * 0.6;
                    const radius = connectRadius * (0.5 + Math.random() * 0.5);
                    dots.push({
                        x: Math.max(margin, Math.min(cx * 2 - margin, cx + Math.cos(angle) * radius)),
                        y: Math.max(margin, Math.min(cy * 2 - margin, cy + Math.sin(angle) * radius))
                    });
                }
                data.dots = dots;
                data.dotSize = params.dot_size; // Store dot size for drawing info
                data.sequential = params.connect_sequential; // Store connection type

                if (data.sequential) {
                    // Generate path segments connecting the dots sequentially
                    for (let i = 0; i < dots.length; i++) {
                        const startDot = dots[i];
                        const endDot = dots[(i + 1) % dots.length]; // Connect back to start
                        points.push(...this.densifyPath([startDot, endDot], step));
                        if (i < dots.length - 1) points.push(null); // Break line
                    }
                } else {
                    // If not sequential, no reference path is drawn, only dots
                    points.push(...dots); // Store dots, but path length will be 0
                }
             }

            generateCombinedShapesPath(points, data, params, cx, cy, availW, availH, step) {
                 // Example: Circle inside a square
                 const outerSize = Math.min(params.size, availW, availH);
                 const innerSize = outerSize * 0.5;
                 const halfOuter = outerSize / 2;
                 const x0=cx-halfOuter, y0=cy-halfOuter, x1=cx+halfOuter, y1=cy+halfOuter;

                 // Draw square (sharp corners for simplicity here)
                 for (let x = x0; x <= x1; x += step) points.push({ x, y: y0 }); points.push(null);
                 for (let y = y0; y <= y1; y += step) points.push({ x: x1, y }); points.push(null);
                 for (let x = x1; x >= x0; x -= step) points.push({ x, y: y1 }); points.push(null);
                 for (let y = y1; y >= y0; y -= step) points.push({ x: x0, y }); points.push(null);
                 points.push({x: x0, y: y0}); // Connect back
                 points.push(null); // Break before circle

                 // Draw circle
                 const r = innerSize / 2;
                 if (r >= step) {
                    const startPoint = { x: cx + r, y: cy };
                    points.push(startPoint); // Start point for circle
                    for (let a = (step / r); a < Math.PI * 2; a += (step / r)) points.push({ x: cx + Math.cos(a) * r, y: cy + Math.sin(a) * r });
                    points.push(startPoint); // Close circle
                 }
            }

            // --- Target Practice Specific Logic ---
            generateTargets() {
                this.clearTargets(); // Clear existing DOM elements
                this.targets = [];
                this.targetsHit = 0;
                const dpr = window.devicePixelRatio || 1;
                const canvasWidth = this.canvas.width / dpr;
                const canvasHeight = this.canvas.height / dpr;
                const count = this.currentParams.target_count || 10;
                const size = this.currentParams.target_size || 20;
                const margin = size * 1.5; // Ensure space around edges

                for (let i = 0; i < count; i++) {
                    const target = {
                        x: Math.random() * (canvasWidth - 2 * margin) + margin,
                        y: Math.random() * (canvasHeight - 2 * margin) + margin,
                        size: size,
                        hit: false,
                        element: document.createElement('div')
                    };
                    target.element.classList.add('target-dot');
                    target.element.style.width = `${size}px`;
                    target.element.style.height = `${size}px`;
                    target.element.style.left = `${target.x - size / 2}px`; // Center the dot
                    target.element.style.top = `${target.y - size / 2}px`;
                    target.element.dataset.index = i; // Store index if needed
                    this.targetContainer.appendChild(target.element);
                    this.targets.push(target);
                }
                this.updateTargetProgressDisplay();
            }

            clearTargets() {
                this.targetContainer.innerHTML = ''; // Remove all dot elements
                this.targets = [];
                this.targetsHit = 0;
            }

            handleTargetHit(element) {
                 if (!this.exerciseActive || element.classList.contains('hit')) return;

                 const index = parseInt(element.dataset.index);
                 if (!isNaN(index) && this.targets[index]) {
                     this.targets[index].hit = true;
                     element.classList.add('hit');
                     this.targetsHit++;
                     this.updateTargetProgressDisplay();

                     // Check if all targets are hit
                     if (this.targetsHit === this.targets.length) {
                         this.completeExercise();
                     }
                 }
            }

            updateTargetProgressDisplay() {
                if (this.currentExerciseType === 'target_practice') {
                    this.targetPracticeProgressDiv.classList.remove('hidden');
                    this.targetsHitSpan.textContent = this.targetsHit;
                    this.targetsTotalSpan.textContent = this.targets.length;
                    // Update main progress bar as well
                    this.completionPercent = this.targets.length > 0 ? Math.floor((this.targetsHit / this.targets.length) * 100) : 0;
                    this.updateCompletionDisplay();
                } else {
                    this.targetPracticeProgressDiv.classList.add('hidden');
                }
            }


            // --- Calculations & Statistics ---

            calculatePathLength(points) {
                let length = 0;
                if (!Array.isArray(points)) return 0;
                for (let i = 0; i < points.length - 1; i++) {
                    if (points[i] !== null && points[i+1] !== null) {
                       length += distance(points[i], points[i + 1]); // Use utility function
                    }
                }
                return length;
            }

            findClosestPointOnPath(p, path) {
                let minDistSq = Infinity;
                let closestPoint = null;
                let closestSegmentIndex = -1;
                if (!p || !Array.isArray(path)) return { point: null, distance: Infinity, segmentIndex: -1 };

                for (let i = 0; i < path.length - 1; i++) {
                    const p1 = path[i]; const p2 = path[i + 1];
                    if (p1 === null || p2 === null) continue;

                    const lenSq = Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2);
                    let projection, distSq;

                    if (lenSq < 1e-9) {
                        projection = p1; distSq = Math.pow(p.x - p1.x, 2) + Math.pow(p.y - p1.y, 2);
                    } else {
                        let t = ((p.x - p1.x) * (p2.x - p1.x) + (p.y - p1.y) * (p2.y - p1.y)) / lenSq;
                        t = Math.max(0, Math.min(1, t));
                        projection = { x: p1.x + t * (p2.x - p1.x), y: p1.y + t * (p2.y - p1.y) };
                        distSq = Math.pow(p.x - projection.x, 2) + Math.pow(p.y - projection.y, 2);
                    }
                    if (distSq < minDistSq) { minDistSq = distSq; closestPoint = projection; closestSegmentIndex = i; }
                }
                 if (path.length > 0 && path[path.length - 1] !== null) {
                    const lastP = path[path.length - 1];
                    const distSq = Math.pow(p.x - lastP.x, 2) + Math.pow(p.y - lastP.y, 2);
                     if (distSq < minDistSq) {
                         minDistSq = distSq; closestPoint = lastP;
                         for (let k = path.length - 2; k >= 0; k--) { if (path[k] !== null) { closestSegmentIndex = k; break; } }
                     }
                 }
                return { point: closestPoint, distance: Math.sqrt(minDistSq), segmentIndex: closestSegmentIndex };
            }

            getDeviationAtPoint(p) {
                 if (!this.referencePath || !this.referencePath.points || this.referencePath.points.length < 1 || this.currentExerciseType === 'target_practice') return 0;
                 const closest = this.findClosestPointOnPath(p, this.referencePath.points);
                 return closest.distance;
            }

            calculateDeviationMap() {
                 if (!this.referencePath || this.allStrokes.length === 0 || this.currentExerciseType === 'target_practice') { this.deviationMap = null; return; }
                 const mapWidth = this.canvas.width; const mapHeight = this.canvas.height;
                 if (!this.deviationMap || this.deviationMap.length !== mapWidth * mapHeight) {
                    this.deviationMap = new Float32Array(mapWidth * mapHeight);
                 } else { this.deviationMap.fill(0); }
                 const influenceRadius = Math.max(2, Math.ceil(this.lineWidth / 2));
                 const dpr = window.devicePixelRatio || 1;

                 for (const stroke of this.allStrokes) {
                     for (const point of stroke) {
                         const deviation = point.deviation;
                         if (deviation > 0.1) {
                             const x = Math.floor(point.x * dpr); // Scale to buffer coords
                             const y = Math.floor(point.y * dpr);
                             for (let dy = -influenceRadius; dy <= influenceRadius; dy++) {
                                 for (let dx = -influenceRadius; dx <= influenceRadius; dx++) {
                                     if (dx * dx + dy * dy <= influenceRadius * influenceRadius) {
                                         const mapX = x + dx; const mapY = y + dy;
                                         if (mapX >= 0 && mapX < mapWidth && mapY >= 0 && mapY < mapHeight) {
                                             const index = mapY * mapWidth + mapX;
                                             this.deviationMap[index] = Math.max(this.deviationMap[index] || 0, deviation);
                                         }
                                     }
                                 }
                             }
                         }
                     }
                 }
            }

            calculateCompletion() {
                 if (this.currentExerciseType === 'target_practice') {
                    // Completion handled by target hits
                    this.completionPercent = this.targets.length > 0 ? Math.floor((this.targetsHit / this.targets.length) * 100) : 0;
                 } else if (!this.referencePath || this.referencePath.totalLength < 1e-3 || this.allStrokes.length === 0) {
                    this.completionPercent = 0;
                 } else {
                     const coveredThreshold = this.lineWidth * 1.5;
                     const coveredSegments = new Set();
                     for (const stroke of this.allStrokes) {
                         for(const point of stroke) {
                             if (point.deviation < coveredThreshold * 2) {
                                 const closest = this.findClosestPointOnPath(point, this.referencePath.points);
                                 if (closest.segmentIndex !== -1 && point.deviation < coveredThreshold) {
                                     coveredSegments.add(closest.segmentIndex);
                                 }
                             }
                         }
                     }
                     let coveredLength = 0;
                     for (const index of coveredSegments) {
                         if (index >= 0 && index < this.referencePath.points.length - 1 &&
                             this.referencePath.points[index] !== null && this.referencePath.points[index + 1] !== null) {
                             coveredLength += distance(this.referencePath.points[index], this.referencePath.points[index + 1]);
                         }
                     }
                     this.completionPercent = Math.min(100, Math.floor((coveredLength / this.referencePath.totalLength) * 100));
                 }
                 this.updateCompletionDisplay();
            }

            updateLiveStats(point) {
                if (!point) return;
                this.pressureValueDisplay.textContent = point.pressure?.toFixed(2) ?? '0.00';
                const tiltX = point.tiltX || 0; const tiltY = point.tiltY || 0;
                const tiltAngle = Math.sqrt(tiltX * tiltX + tiltY * tiltY) * (180 / Math.PI);
                this.tiltValueDisplay.textContent = `${tiltAngle.toFixed(0)}°`;
                this.speedValueDisplay.textContent = `${point.speed?.toFixed(0) ?? '0'}px/s`; // Show live speed
            }

            calculateOverallStats() {
                let totalDeviation = 0, totalAngleChange = 0, totalJitter = 0;
                let pointCount = 0, segmentCount = 0, totalSpeed = 0, speedPointCount = 0;
                let pressureDiffSumSq = 0, pressurePointCount = 0;

                for (const stroke of this.allStrokes) {
                    pointCount += stroke.length;
                    for (let i = 0; i < stroke.length; i++) {
                        const p = stroke[i];
                        totalDeviation += p.deviation || 0;
                        if (p.speed !== undefined && i > 0) { totalSpeed += p.speed; speedPointCount++; }

                        // Pressure Accuracy Calculation (only for pressure type)
                        if (this.currentExerciseType === 'pressure' && this.referencePath?.points) {
                           const closestRef = this.findClosestPointOnPath(p, this.referencePath.points);
                           if (closestRef.point && closestRef.point.targetPressure !== undefined) {
                               pressureDiffSumSq += Math.pow(p.pressure - closestRef.point.targetPressure, 2);
                               pressurePointCount++;
                           }
                        }
                    }
                    if (stroke.length >= 3) {
                        segmentCount += stroke.length - 2;
                        for (let i = 1; i < stroke.length - 1; i++) {
                            const p0 = stroke[i - 1], p1 = stroke[i], p2 = stroke[i + 1];
                            // Smoothness
                            const ang1 = Math.atan2(p1.y - p0.y, p1.x - p0.x); const ang2 = Math.atan2(p2.y - p1.y, p2.x - p1.x);
                            let angC = Math.abs(ang1 - ang2); if (angC > Math.PI) angC = 2 * Math.PI - angC;
                            totalAngleChange += angC;
                            // Jitter
                            const lenSq = Math.pow(p2.x - p0.x, 2) + Math.pow(p2.y - p0.y, 2);
                            if (lenSq > 1e-6) { const area = Math.abs((p2.x - p0.x) * (p1.y - p0.y) - (p1.x - p0.x) * (p2.y - p0.y)); totalJitter += area / Math.sqrt(lenSq); }
                        }
                    }
                }

                const avgDeviation = pointCount > 0 ? totalDeviation / pointCount : 0;
                const maxPossibleAngleChange = Math.PI * segmentCount;
                const smoothness = maxPossibleAngleChange > 0 ? Math.max(0, 1 - totalAngleChange / maxPossibleAngleChange) : (pointCount > 1 ? 1 : 0);
                const jitter = segmentCount > 0 ? totalJitter / segmentCount : 0;
                const avgSpeed = speedPointCount > 0 ? totalSpeed / speedPointCount : 0;
                // Pressure Accuracy (0-1, lower RMS error is better -> higher accuracy)
                const rmsPressureError = pressurePointCount > 0 ? Math.sqrt(pressureDiffSumSq / pressurePointCount) : 1; // Max error = 1 (0-1 range)
                const pressureAccuracy = Math.max(0, 1 - rmsPressureError / 0.5); // Normalize (assuming avg error > 0.5 is 0% accuracy)

                // Update displays
                this.smoothnessValueDisplay.textContent = `${(smoothness * 100).toFixed(0)}%`;
                this.deviationValueDisplay.textContent = `${avgDeviation.toFixed(1)}px`;
                this.jitterValueDisplay.textContent = jitter.toFixed(2);
                this.speedValueDisplay.textContent = `${avgSpeed.toFixed(0)}px/s`;
                this.pressureAccuracyValueDisplay.textContent = (this.currentExerciseType === 'pressure') ? `${(pressureAccuracy * 100).toFixed(0)}%` : '-';

                return { avgDeviation, jitter, smoothness, avgSpeed, pressureAccuracy };
            }

            // --- UI Updates ---
            updateCompletionDisplay() { this.completionPercentDisplay.textContent = this.completionPercent; this.exerciseProgress.value = this.completionPercent; }
            updateAttemptDisplay() { this.attemptCountDisplay.textContent = this.attemptCount; }
            updateScoreDisplay() { this.currentScoreValueDisplay.textContent = this.currentScore; }
            updateHistoryDisplay() {
                this.todayExercisesDisplay.textContent = this.todayExercises;
                this.totalScoreDisplay.textContent = this.totalScore;
                this.highestLevelDisplay.textContent = this.highestLevelAchieved;
            }

            // --- Timer ---
            startTimer() { this.stopTimer(); this.startTime = Date.now(); this.timerDisplay.textContent = '00:00'; this.timerInterval = setInterval(() => { const e=Math.floor((Date.now()-this.startTime)/1000),m=Math.floor(e/60),s=e%60; this.timerDisplay.textContent=`${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;}, 1000); }
            stopTimer() { if (this.timerInterval) { clearInterval(this.timerInterval); this.timerInterval = null; } }

            // --- Persistence ---
            saveProgress() { try { const t={todayExercises:this.todayExercises,totalScore:this.totalScore,highestLevelAchieved:this.highestLevelAchieved,currentMode:this.currentMode,lastExercise:this.currentExerciseType,lastParams:this.currentParams,showGuide:this.showGuide,showHeatmap:this.showHeatmap,colorFeedback:this.colorFeedback,maxFadeStrokes:this.maxFadeStrokes,lineWidth:this.lineWidth}; localStorage.setItem("drawingTrainerProgress_v4",JSON.stringify(t))} catch(e) {console.error("Failed to save progress:",e)} } // Incremented key
            loadProgress() { try { const t=localStorage.getItem("drawingTrainerProgress_v4"); if(t){const e=JSON.parse(t);this.todayExercises=e.todayExercises||0;this.totalScore=e.totalScore||0;this.highestLevelAchieved=e.highestLevelAchieved||0;this.currentMode=e.currentMode||"practice";this.currentExerciseType=e.lastExercise||"straight";this.currentParams=e.lastParams||{};this.showGuide=e.showGuide!==void 0?e.showGuide:!0;this.showHeatmap=e.showHeatmap!==void 0?e.showHeatmap:!0;this.colorFeedback=e.colorFeedback!==void 0?e.colorFeedback:!1;this.maxFadeStrokes=e.maxFadeStrokes||10;this.lineWidth=e.lineWidth||5}} catch(e) {console.error("Failed to load progress:",e);this.todayExercises=0;this.totalScore=0;this.highestLevelAchieved=0;this.currentParams={}} this.ensureDefaultParams(); this.updateHistoryDisplay(); }
        }

        // --- Challenge Mode Logic ---
        class ChallengeModeManager {
            constructor() {
                // Define difficulty tiers and exercises within them
                this.tiers = [
                    // Tier 1: Basics
                    [ { type: 'straight', params: { size: [200, 400] }, targetScore: 70 }, // Size range
                      { type: 'circle', params: { size: [150, 250] }, targetScore: 75 } ],
                    // Tier 2: Basic Shapes & Angles
                    [ { type: 'square', params: { size: [120, 220], corner_radius: [0, 10] }, targetScore: 75 },
                      { type: 'angled', params: { size: [200, 350], angle: [15, 75] }, targetScore: 70 }, // Angle range
                      { type: 'ellipse', params: { size: [180, 280], ratio: [0.4, 0.7] }, targetScore: 75 } ],
                    // Tier 3: Curves & Simple Control
                    [ { type: 'smooth', params: { size: [300, 500], amplitude: [30, 60], frequency: [1, 3], smoothness: [0.3, 0.7] }, targetScore: 80 },
                      { type: 'pressure', params: { size: [300, 450] }, targetScore: 75 },
                      { type: 'zigzag', params: { size: [250, 400], amplitude: [40, 80], segments: [4, 8], smoothness: [0, 0.4] }, targetScore: 80 } ],
                    // Tier 4: Complex Curves & Combinations
                    [ { type: 'wave', params: { size: [350, 500], amplitude: [20, 50], frequency: [3, 5], smoothness: [0.4, 0.8] }, targetScore: 85 },
                      { type: 'spiral', params: { size: [200, 300], rotations: [2, 4], start_radius: [0, 10] }, targetScore: 80 },
                      { type: 'random_curve', params: { size: [350, 500], amplitude: [40, 80], frequency: [3, 5] }, targetScore: 82 } ], // Random curves are harder to score consistently
                    // Tier 5: Precision & Dexterity
                    [ { type: 'connect_dots', params: { size: [250, 400], dot_count: [5, 8], dot_size: [8, 15], connect_sequential: true }, targetScore: 85 },
                      { type: 'target_practice', params: { target_count: [8, 15], target_size: [15, 25] }, targetScore: 88 },
                      { type: 'trace', params: { size: [150, 250] }, targetScore: 85 },
                      { type: 'combined_shapes', params: { size: [200, 300] }, targetScore: 80 } ],
                     // Tier 6: High Precision
                    [ { type: 'circle', params: { size: [80, 120] }, targetScore: 90 }, // Small targets
                      { type: 'square', params: { size: [70, 110], corner_radius: [5, 15] }, targetScore: 90 },
                      { type: 'connect_dots', params: { size: [300, 450], dot_count: [8, 12], dot_size: [5, 10], connect_sequential: true }, targetScore: 90 },
                      { type: 'target_practice', params: { target_count: [15, 25], target_size: [10, 20] }, targetScore: 92 } ],
                ];
            }

            getLevelDefinition(levelIndex) {
                if (levelIndex < 0) return null;
                // Determine tier based on level index (e.g., every 3 levels increase tier)
                const tierIndex = Math.min(this.tiers.length - 1, Math.floor(levelIndex / 3));
                const tier = this.tiers[tierIndex];

                // Randomly select an exercise definition from the tier
                const exerciseDef = { ...tier[Math.floor(Math.random() * tier.length)] }; // Deep copy needed? Maybe not for params

                // Randomize parameters within defined ranges
                const randomizedParams = {};
                for (const key in exerciseDef.params) {
                    const value = exerciseDef.params[key];
                    if (Array.isArray(value)) { // It's a range [min, max]
                        const min = value[0];
                        const max = value[1];
                        // Check if integer or float range needed
                        if (Number.isInteger(min) && Number.isInteger(max)) {
                            randomizedParams[key] = Math.floor(Math.random() * (max - min + 1)) + min;
                        } else { // Float range
                            randomizedParams[key] = Math.random() * (max - min) + min;
                            // Round floats like ratio, smoothness to 1 decimal place
                            if (['ratio', 'smoothness'].includes(key)) {
                                randomizedParams[key] = parseFloat(randomizedParams[key].toFixed(1));
                            }
                        }
                    } else { // It's a fixed value
                        randomizedParams[key] = value;
                    }
                }
                exerciseDef.params = randomizedParams;

                // Adjust target score slightly based on level within tier? (Optional)
                exerciseDef.targetScore += (levelIndex % 3); // Increase target slightly for later levels in tier

                exerciseDef.completionThreshold = exerciseDef.completionThreshold ?? 90;

                // Ensure all necessary default params are present
                const defaults = { size: 150, angle: 45, ratio: 0.6, amplitude: 50, frequency: 3, rotations: 3, dot_count: 5, segments: 8, corner_radius: 0, start_radius: 5, dot_size: 10, connect_sequential: true, target_count: 10, target_size: 20, smoothness: 0.5 };
                exerciseDef.params = { ...defaults, ...exerciseDef.params };

                return exerciseDef;
            }
        }

        // --- Initialize ---
        window.addEventListener('DOMContentLoaded', () => { window.drawingTrainer = new DrawingTrainer(); });
    </script>
</body>
</html>
